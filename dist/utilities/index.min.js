const objectToMap=(o={})=>{let e=new Map;for(const n in o)e.set(n,o[n]);return e},debounce=(fn,delay=400)=>{let n=null;return function(){let e=arguments;clearTimeout(n),n=setTimeout(()=>{fn.apply(this,e)},delay)}};class Binding{constructor(value){this._listeners=[],this._value=value}notify(){this._listeners.forEach(listener=>listener(this._value))}subscribe(listener){this._listeners.push(listener)}get value(){return this._value}set value(newValue){newValue!==this._value&&(this._value=newValue,this.notify())}}class Computed extends Binding{constructor(value,deps){super(value());const e=()=>{this._value=value(),this.notify()};deps.forEach(dep=>dep.subscribe(e))}get value(){return this._value}set value(_){throw"cannot set value on computed property"}}function applyBindings(container){document.querySelectorAll("[data-bind]").forEach(el=>{var e=container[el.getAttribute("data-bind")];console.log(el.nodeName),("INPUT"===el.nodeName?bindInput:bindNode)(el,e)})}function bindInput(input,observable){input.value=observable.value,observable.subscribe(()=>input.value=observable.value),input.addEventListener("keyup",()=>{observable.value=input.value})}function bindNode(node,observable){node.innerText=observable.value,observable.subscribe(()=>node.innerText=observable.value)}export{Binding,Computed,applyBindings,debounce,objectToMap};