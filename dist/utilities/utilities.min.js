const objectToMap=(o={})=>{let e=new Map;for(const t in o)e.set(t,o[t]);return e},debounce=(fn,delay=400)=>{let t=null;return function(){let e=arguments;clearTimeout(t),t=setTimeout(()=>{fn.apply(this,e)},delay)}};class Binding{constructor(name,value){this._name=name,this._listeners=[],this._value=value}notify(){this._listeners.forEach(listener=>listener(this._name,this._value))}subscribe(listener){this._listeners.push(listener)}subscriberCount(){return this._listeners.length}clear(newValue=""){this._value=newValue,this.notify()}get name(){return this._name}get value(){return this._value}set value(newValue){newValue!==this._value&&(this._value=newValue,this.notify())}}class Computed extends Binding{constructor(value,deps=[]){super("computed",value());const e=()=>{this._value=value(),this.notify()};deps.forEach(dep=>dep.subscribe(e))}get value(){return this._value}set value(_){throw"cannot set value on computed property"}}function applyBindings(container,options={selector:"data-bind"}){options={selector:"data-bind",...options},document.querySelectorAll(`[${options.selector}]`).forEach(el=>{var e=container[el.getAttribute(options.selector)];("INPUT"===el.nodeName?bindInput:"SELECT"===el.nodeName?bindSelect:bindNode)(el,e)})}function bindInput(input,observable){input.value=observable.value,0===observable.subscriberCount()&&observable.subscribe(()=>input.value=observable.value),input.addEventListener("keyup",()=>{observable.value=input.value})}function bindSelect(input,observable){input.selectedIndex=observable.value,0===observable.subscriberCount()&&observable.subscribe(()=>{console.log(`observable for ${observable.name} changed to '${observable.value}'`),input.selectedIndex=observable.value}),input.addEventListener("change",e=>{observable.value=e.target.selectedIndex})}function bindNode(node,observable){node.innerText=observable.value,observable.subscribe(()=>node.innerText=observable.value)}export{Binding,Computed,applyBindings,debounce,objectToMap};